Сервис nginx помогает быстро создать вервер и передавать клиентам (браузеры, приложения) разные 
статичные файлы (картинки, html-файлы, css-файлы, скрипты)

docker run nginx - не найдет Л, скачает с ДокерХаба, причем скачается несколько (6) слоев 
(у каждого свой id) - 1fe172e4850f: Pulling fs layer ... . Слои скачиваются архивами и распаковываются.

После создания контейнера мы автоматически подключены к процессу внутри него.
То есть на экране мы по сути видим логи сервера nginx: 
...
2022/04/22 09:40:22 [notice] 1#1: using the "epoll" event method
2022/04/22 09:40:22 [notice] 1#1: nginx/1.21.6
2022/04/22 09:40:22 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)
2022/04/22 09:40:22 [notice] 1#1: OS: Linux 5.4.72-microsoft-standard-WSL2
2022/04/22 09:40:22 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
...

1. Как подключиться к созданному веб-серверу nginx, который мы создали?
2. Как вернуться в командную строку из логов?

Сначала зпросим отчет по текущему состоянию: docker ps
Получим:
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
1e11b1aec894   nginx     "/docker-entrypoint.…"   5 minutes ago   Up 5 minutes   80/tcp    hopeful_leakey

Видим в колонке PORTS значение 80/tcp.
Это означает, что внутри контейнера открыт порт 80 и к нему можно подключиться.
Этот порт был открыт процессом, потому что веб-сервер работает на порту.
И потому что открыт порт - контейнер работает, не останавливается.

Чтобы подключиться к веб-серверу, который запущен внутри контейнера? Пока никак, надо настроить 
mapping портов. Об этом позже.

Как запустить контейнер в бэк-граунде, чтобы сразу не  подключаться к процессу вывода логов?
Есть запуск в фоновом режиме: docker run -d nginx (ult в - deattashed, отсоединенный)

Чтобы перезапустить сначала остановим контейнер: docker stop <id>
Проверим, что все чисто: docker ps
И теперь вызовем снова: docker run -d nginx
Выховем список и увидим, что его STATUS Up 5 seconds

Важно! Каждый запуск команды run создает новый контейнер, 
запущенные и остановленные ранее просто остаются.

Чтобы узнать ip-адрес контейнера, нужно взять его id и вызвать команду:
docker container inspect 1d44d3b49d05
Выдает большой json-файл, деталей много, но нужное нам в самом конце: "IPAddress": "172.17.0.2"

Чтобы не смотреть всю портянку, можно воспользоваться фильтром:
docker container inspect 1d44d3b49d05 | grep IPAddress

Попробуем подключиться к этому адресу: скопируем его, откроем браузер и введем в адресную строку:
Получим: Не удается получить доступ к сайту
Кстати, он пытался подключиться к порту 80, это по умолчанию для протокола http

Остановим процесс:
когда мы передаем docker stop <id>, мы просим Докер остановить процесс внутри контейнера.
Возможно, что процесс не будет отвечать, тогда жестче: docker kill <id>

--------------------
Запуск дополнительного процесса в уже запущенном контейнере
docker exec -it <id> bash, где exec - выполняет команду в запущенном контейнере, -it подключение интерактивного 
терминала, bash - название процесса.

Пример: создадим и запустим docker run -d nginx, узнаем его имя и запустим docker exec -it <id> bash
Теперь мы находимся в командной строке bash внутри контейнера

--------------------
Чтобы создать контейнер с кастомным именем:
docker run -d --name my_nginx_name nginx
